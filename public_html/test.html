<!DOCTYPE html>
<html>
	<head>
		<title>test</title>
		<style>	
			body {
				width: 1000px;
				margin: auto;
				position: relative;
			}

			#line-white {
				fill: steelblue;
				stroke: 1px;
			}
			
			svg {
				margin: { top:20, bottom:20, left: 20, right:20};
				
			}
			
			
			 
			


		</style>
	</head>
	<body>
		<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>

		<script>
			
	var datasetW = [
				{'year': '2002', 'pov': 15567},
				{'year': '2003', 'pov': 15902},
				{'year': '2004', 'pov': 16908},
				{'year': '2005', 'pov': 16227},
				{'year': '2006', 'pov': 16013},
				{'year': '2007', 'pov': 16032},
				{'year': '2008', 'pov': 17024},
				{'year': '2009', 'pov': 18530},
				{'year': '2010', 'pov': 19251},
				{'year': '2011', 'pov': 19171},
				{'year': '2012', 'pov': 18940},
				{'year': '2013', 'pov': 18796},
			];
		
			var margin = { top: 20, right: 50, bottom: 30, left: 40 },
					width = 960 - margin.left - margin.right,
					height = 500 - margin.top - margin.bottom;
	
			var svg = d3.selectAll('body').append('svg')
							.attr('width', width + margin.left + margin.right)
							.attr('height', height + margin.top + margin.bottom)
							.append('g')
							.attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
			
			var parseDate = d3.time.format('%Y').parse,
					bisectDate = d3.bisector(function(d) { return d.year; }).left,
					formatValue = d3.format(',.2f'),
					formatCurrency = function(d) { return '$' + formatValue(d); };
			var x = d3.time.scale().range([0, width]);
			var y = d3.scale.linear().range([height, 0]);
			
			var xAxis = d3.svg.axis()
							.scale(x)
							.orient('bottom');
			
			var yAxis = d3.svg.axis()
							.scale(y)
							.orient('left')
							.ticks(10);
			
			var line = d3.svg.line()
							.x(function(d) { return x(d.year); })
							.y(function(d) { return y(d.pov); })
							.interpolate('monotone');
			
			
			datasetW.forEach(function(d) {
				d.year = parseDate(d.year);
				d.pov = +d.pov;
			});
			
// 			datasetW.sort(function(a, b) {
// 				return a.year - b.year;
// 			});
			
			x.domain([datasetW[0].year, datasetW[datasetW.length - 1].year]);
			y.domain(d3.extent(datasetW, function(d) { return d.pov; }));
			
			svg.append('g')
							.attr('class', 'x-axis')
							.attr('transform', 'translate(0,' + height + ')')
							.call(xAxis);
			
			svg.append('g')
							.attr('class', 'y-axis')
							.call(yAxis)
							.append('text')
							.attr('y', 6)
							.attr('dy', '.71em')
							.style('text-anchor', 'end')
							.text('Poverty Population');
			
			svg.append('path')
							.datum(datasetW)
							.attr('class', 'line')
							.attr('d', line);
//			
//			var focus = svg.append('g')
//							.attr('class', 'focus')
//							.style('display', 'none');
//			
//			focus.append('circle')
//							.attr('r', 4.5);
//			
//			focus.append('text')
//							.attr('x', 9)
//							.attr('dy', '.35em');
			
//			svg.append('rect')
//							.attr('class', 'overlay')
//							.attr('width', width)
//							.attr('height', height)
//							.on('mouseover', function() { focus.style('display', null); })
//							.on('mouseout', function() { focus.style('display', 'none'); })
//							.on('mousemove', mousemove());
			
//			function mousemove() {
//				var x0 = x.invert(d3.mouse(this)[0]),
//						i = bisecDate(year, x0, 1),
//						d0 = datasetW[i-1],
//						d1 = datasetW[i],
//						d = x0 - d0.year > d1.year - x0 ? d1 : d0;
//						focus.attr('transform', 'translate(' + x(d.year) + ',' + y(d.pov) + ')');
//						focus.select('text').text(formatCurrency(d.pov));
//			}


		</script>
	</body>
</html>	
